# Input format
You will be provided with a valid python code containing a dict of `table_data` with the following keys.
- `columns`: An array of strings, each representing the name of a table column.
- `data`: A 2D array where each nested list represents a row in the table, with each element corresponding to the cells in that row under each column.
- `index`: An array of integer or string, each representing the index of a table row.
  - Note: The rows in the data are numbered starting from 0 up to the total number of rows minus one (for example, if there are 10 rows, they would be numbered from 0 to 9). The header row, if present, is not included in these numbers; only rows with actual data are counted.
- `Queries`: A array of string containing the user's sub-queries or request for specific information from the table.

Analyze the table’s structure by recognizing the relation between columns and their respective cells in data. Use these associations to identify relevant information in each cell that pertains to the Query.

The input format is as follows:

```python
table_data = {
  "columns": ["column_name_1", "column_name_2", "column_name_3"],
  "data": [
    ["Cell 1", "Cell 2", "Cell 3"],
    ["Cell 4", "Cell 5", "Cell 6"]
  ],
  "Queries": ["The user query string."],
  "index": [0,1],
}
table_df = pd.DataFrame(table_data['data'], columns=table_data['columns'])
```

# Task instructions

You should follow these requirements below:

- Analyze the Queries:
  - For each sub-query, provide the following:
    - Sub-query order: Label each sub-query in order (e.g., "Sub-query 1:", "Sub-query 2:", etc.).
    - Column and row indices: Identify the relevant columns and rows in the table that are needed to answer the sub-query.
    - Python code: For each sub-query, write the corresponding Python code to extract the relevant data and compute the answer.
- Code Quality:
  - The Python code must be concise, easy to understand, and modular.
  - If necessary, add comments for clarity.
  - Follow best practices for code efficiency and readability.
- Data Context:
  - Base your analysis entirely on the provided table data. Do not use any external data or make assumptions.
  - If the Query is not related to the provided table data, politely refuse and provide a response explaining why.
- Handling Multiple Sub-Queries:
  - For multiple sub-queries, print each sub-query’s order (e.g., "Sub-query 1:", "Sub-query 2:").
  - For each sub-query, identify the relevant column and row indices and extract the necessary information.
  - For each sub-query, generate Python code to retrieve the data from the table.
- Data Type Casting:
  - Identify every column in the DataFrame and cast columns to appropriate data types (e.g., int, float, object) if necessary to ensure the code executes correctly.
- Output Formatting:
  - Provide Only Python code that loads the table data using the pandas library, don't response any other description.
  - Ensure to load the table with command ```table_df = pd.DataFrame(table_data['data'], columns=table_data['columns'])```. Assume `table_data` is already defined and available in the environment, so it doesn't need to explain or define it further.
  - If the Query involves numerical calculations, perform them using DataFrame methods to get the final answers and print the final answers.
    - Print the final answers: Ensure that the final output includes the print() function to display answers. Do not print any other description information.
    - Handle numerical outputs: For any query involving calculations, format the final answer using Python’s rounding function `round()` to ensure that results are output with exactly two decimal places.

Replace index_1, index_2, etc., with the actual indices based on the identified columns and rows. If no columns or rows are identified as relevant, return an empty array for that key.

# Example Reformulations

## Input Example
```python
table_data = {
  "columns": ["Product Name", "Sales $"],
  "data": [
    ["ProductA", 450],
    ["ProductB", 600],
    ["ProductC", 750],
    ["ProductD", 200]
  ],
  "index": [0,1,2,3],
  "Queries": ["What is the average sales of products with sales greater than 500", "which product has the best sales"]
}
table_df = pd.DataFrame(table_data['data'], columns=table_data['columns'])
```

## Output Example
```python
# table_data has been loaded into python environment.
table_df = pd.DataFrame(table_data['data'], columns=table_data['columns'])
# Sales $ 需要数值计算，确保要计算的 "Sales $" 列是数值类型
table_df["Sales $"] = pd.to_numeric(table_df["Sales $"], errors='coerce') # errors='coerce' 将无法转换的数识别为 NaN
# 筛选销售大于500的产品
filtered_df = table_df[table_df["Sales $"] > 500]

# 计算平均销售
average_sales = filtered_df["Sales $"].mean()

print(round(average_sales,2)) # Average sales of products with sales greater than 500

# 找到最大销售值
max_sales = table_df["Sales $"].max()

# 获取销售最好的产品名称
best_product = table_df.loc[table_df["Sales $"] == max_sales, "Product Name"].values[0]

print(best_product) # The product name with the best sales
```

# User Input

```python
{{Inputs}}
```